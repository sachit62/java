# How to Solve DSA Questions ‚Äì A Structured Approach

This guide defines a **clear, repeatable process** to solve Data Structures & Algorithms problems effectively, along with a **complete list of core DSA patterns** to recognize problems faster.

---

## üìå Problem-Solving Workflow

Follow these steps **for every DSA question**:

1. **Analyze the problem**
   - Understand constraints
   - Identify the input/output format
   - Decide which **DSA + pattern** fits

2. **Plan before coding**
   - Think about time & space complexity
   - Dry run with sample input

3. **Implement the solution**
   - Write clean, readable code
   - Handle edge cases

4. **If stuck**
   - Give yourself sufficient time
   - Then refer to the solution
   - Understand what you missed
   - **Re-code the solution yourself**

5. **Post-solution**
   - Add the problem to your **revision list**
   - Note any **new concept / trick / pattern**

---

# üß† DSA Patterns ‚Äì Complete Guide

This section summarizes **core problem-solving patterns** in DSA.  
Each pattern includes **when to use it** and **common problem types**.

---

## 1Ô∏è‚É£ Prefix Sum

Used for cumulative calculations when multiple range queries are involved.

**Common Use-Cases**
- Range sum queries
- Subarray sum equals K
- Difference arrays
- Frequency tracking

---

## 2Ô∏è‚É£ Two Pointers

Efficient traversal using two indices moving toward or away from each other.

**Common Use-Cases**
- Pair sum in sorted arrays
- Palindrome checking
- Removing duplicates
- Comparing ranges

---

## 3Ô∏è‚É£ Sliding Window

Used for problems involving **continuous subarrays/substrings**.

**Why use it?**
- Reduces time complexity from `O(n¬≤)` ‚Üí `O(n)`

**Common Use-Cases**
- Longest substring without repeating characters
- Max sum subarray of size K
- Variable window problems

---

## 4Ô∏è‚É£ Fast & Slow Pointer

Pointers move at different speeds to detect cycles or midpoints.

**Common Use-Cases**
- Linked list cycle detection
- Finding middle of a linked list
- Detecting intersections

---

## 5Ô∏è‚É£ Three Pointers

Maintains order or partitions using three indices.

**Common Use-Cases**
- Dutch National Flag problem
- Merge sorted arrays
- In-place rearrangements

---

## 6Ô∏è‚É£ Monotonic Stack

Stack maintained in **increasing or decreasing order**.

**Common Use-Cases**
- Next greater / smaller element
- Stock span problem
- Largest rectangle in histogram

---

## 7Ô∏è‚É£ Top-K Elements

Used when finding **k largest/smallest** elements.

**Common Tools**
- Heap (Priority Queue)
- Quickselect

**Common Use-Cases**
- K largest / smallest elements
- K frequent elements
- Streaming data problems

---

## 8Ô∏è‚É£ Overlapping Intervals

Problems involving time or range overlaps.

**Common Use-Cases**
- Merge intervals
- Meeting rooms
- Conflict detection
- Scheduling problems

---

## 9Ô∏è‚É£ Modified Binary Search

Binary search on **non-traditional sorted data**.

**Common Use-Cases**
- Search in rotated sorted array
- First/last occurrence
- Peak element
- Monotonic condition problems

---

## üîü Binary Tree Traversal

Standard traversal techniques for trees.

**Types**
- Inorder
- Preorder
- Postorder
- Level Order (BFS)

**Common Use-Cases**
- BST operations
- Expression trees
- Tree validation

---

## 1Ô∏è‚É£1Ô∏è‚É£ DFS (Depth-First Search)

Explores deeply before backtracking.

**Common Use-Cases**
- Connected components
- Cycle detection
- Islands problems
- Pathfinding

---

## 1Ô∏è‚É£2Ô∏è‚É£ BFS (Breadth-First Search)

Explores level by level.

**Common Use-Cases**
- Shortest path (unweighted graphs)
- Multi-source BFS
- Level-order traversal

---

## 1Ô∏è‚É£3Ô∏è‚É£ Matrix Traversal

Traversal techniques for 2D grids.

**Common Use-Cases**
- Flood fill
- Spiral matrix
- Grid-based DP
- Island counting

---

## 1Ô∏è‚É£4Ô∏è‚É£ Backtracking

Used when **all combinations or permutations** are required.

> If the problem says *‚Äúfind all possible‚Äù* ‚Üí think **Backtracking**

**Common Use-Cases**
- Subsets
- Permutations
- N-Queens
- Sudoku solver

---

## 1Ô∏è‚É£5Ô∏è‚É£ Dynamic Programming (DP)

Used when problems have:
- Overlapping subproblems
- Optimal substructure

**Common Use-Cases**
- Knapsack
- LIS
- Matrix DP
- DP on trees

---

## 1Ô∏è‚É£6Ô∏è‚É£ Union Find (Disjoint Set Union)

Efficient for merging sets and connectivity checks.

**Common Use-Cases**
- Connected components
- Cycle detection
- Kruskal‚Äôs MST
- Account merging

---

## 1Ô∏è‚É£7Ô∏è‚É£ Greedy Algorithms

Make locally optimal choices hoping for a global optimum.

**Common Use-Cases**
- Activity selection
- Jump Game
- Minimum platforms
- Huffman coding

---
